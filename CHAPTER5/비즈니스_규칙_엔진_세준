- 세준
    
    ## **목표**
    
    - 테스트 주도 기법으로 개로운 설계 문제를 풀어나가는 방법을 배운다.
    - 유닛테스트를 구현하는데 유용한 모킹 기법을 전반적으로 배운다.
    - 지역변수 형식 추론, 새로운 switch 등의 최신 자바 기능을 살펴본다.
    - 빌더패턴과 인터페이스 분리 원칙으로 사용자 친화적인 API 개발 방법을 배운다.
    
    ## **개발하려는 시스템**
    
    마기술팀과 비지니스 팀이 함꼐 뭔가를 만들 수 있는비지니스 규칙 엔진
    
    - 비지니스 팀에서 직접 원하는 규칙을 만들 수 있음
    - ex) 잠재 고객의 직함이 CEO 면 영업팀에게 알림
    
    ## **비지니스 규칙 엔진 요구사항**
    
    프로그래머가 아닌 사람들도 자신의 워크플로에 비지니스 로직을 추가하거나 바꿀 수 있는 기능
    
    - > 마케팅 부서장 : 한 제품에 관심이 쏠리면서 어떤 조건을 만족 할 때 특별 할인을 제공하고 싶음
    - >회계부서장은 지출이 평소보다 높을때 알람을 만들고 싶음
    
    제작하려는 비지니스 규칙 엔진으로 이런 기능을 제공하려고 함.
    
    - > 1개 이상의 비지니스 규칙을 실행하는 소프트웨어로 다양한 컴포넌트를 동시에 지원
    - **팩트** : 규칙이 확인할 수 있는 정보
    - **액션** : 수향하려는 동작
    - **조선** : 액션을 언제 방생시킬지 지정
    - **규칙** : 실행하려는 비지니스 규칙을 지정. 보통 팩트, 액션, 조건을 한 그륩으로 묶어 규칙으로 만듦
    
    **생산성과 관련해서 좋은 점**
    
    - 규칙이 기존의 응용프로그램과 독립된 곳에서 **실행, 유지보수, 테스트** 할 수 있음
    
    5장에서는 이런 제품을 **최소 기능 제품** 으로 일단 개발하고 반복 과정을 거쳐 기능과 접근성을 개선해 나갈 것이다.
    
    ## **테스트 주도 개발**
    
    ### 시작
    
    이제 학습목표중 하나인 테스트 주도 개발 기법을 이용해보자.
    
    1. 일단 사용자가 수행할 기본 기능은???
    
    - 액션 추가
    - 액션 실행
    - 기본 보고
    
    이렇게 3개가 있다.
    
    각각의 기능을 BusinessRuleEngine에 메소드로 추가하고, 아직 지원되지 않기 때문에 UnsupportedOperationException을 추가하자.
    
    - 클래스 :BusinessRuleEngine
        - 메소드
            - addAction(Action action) // 액션 추가
            - count() // 기본 보고(액션 몇개 있는지)
            - run() //액션 실행
    
    2. 실행할 수 있는 코드로 액션을 만든다. Runnable 인터페이스를 쓸수도 있지만, 도메인을 반영해 Action이라는 별도의 인터페이스를 만드는게 좋다.
    
    Action 인터페이스를 이용해 비지니스 규칙 엔진과 구체적액션의 결합을 제거한다. 1개의 메소드만 있기 때문에 Funtional Interaface 어노테이션을 붙일 수있다.
    
    ### TDD를 하는 이유, TDD 주기
    
    TDD를 사용하는 이유는 ?
    
    - 테스트를 따로 구현하므로 테스트에 대응하는 요구사항을 한개씩 구현할 때 마다 요구사항에 집중하고 개선할 수 있다.
    - 코드를 올바르게 조직할 수 있다. 테스트 코드를 먼저 구현하는 것을 통해 어떤 공개 인터페이스를 만들지 신중히 검토함
    - TDD 주기에 따라 요구사항 구현을 반복하면서 종합적인 테스트 스위트를 완성할 수 있으므로 요구사항을 만족 시켰다는 사실을 조금 더 확신할 수 있으며, 버그 발생 범위도 줄일 수 있다.
    - 테스트 통과를 위한 코드를 구현하기 때문에 필요하지 않은 테스트를 구현하는 일(오버엔지니어링) 을 줄일 수 있다.
    
    TDD는 다음의 주기를 따른다.
    
    1. 실패하는 테스트 구현
    2. 모든 테스트 실행
    3. 기능이 동작하도록 코드 구현
    4. 모든 테스트 실행
    
    (테스트는 기능별로 달고 가발하는게 맞을까?)
    
    실 세계에서 코드는 항상 리팩토링이 필요하기 때문에 아래와 같은 테스트 주기를 가진다.
    
    1. 실패하는 테스트 구현
    2. 모든 테스트 실행
    3. 기능이 동작하도록 코드 구현
    4. 모든 테스트 실행(통과)
    5. 리팩토링
    6. 2번으로 돌아감
    
    테스트를 진행할 때 return 값이 없어서 테스트하기 힘들때는 moking을 이용해 해당 메소드가 실행됐는지 검증할 수 있다.
    
    mokito에서는 mock 객체를 생성하고, verify().메소드() 를 이용해 해당 메소드가 해당 테스트에서 실행됐는지 검증할 수 있다.
    
    ex)
    
    Action mockAction = mock(Action.class);
    
    verify(mockAction).perform(); (실행하지 않았다면 여기서 오류발생)
    
    mokito를 이용해 이것 뿐만 아니라 몇번 실행됬는지와 같은 조금 더 복잡한 검증 로직도 실행될 수 있다.
    
    ### 조건 추가하기
    
    ### 지역변수 형식 추론
    
    **var** 키워드를 이용해 지역변수의 형식을 추론할 수 있다. var를 이용했을때 얻는 이득은 주관적이기 때문에 var로 가독성에 문제가 없다면 var를 사용하고 그렇지 않다면 var를 사용하지 않는게 좋다.
    
    ### 발전된 switch문
    
    자바 12에서 보다 발전된 switch 문이 추가도었다. break 문같은것없이 다음과 같은 코드가 사용될 수 있다.
    
    enum 타입을 넘기면 처리되지 않은 enum 타입이 있을경우 컴파일 에러가 발생한다.
    
    var forecastedAmount = amount * switch(dealStage) {
    
    case LEAD -> 0.2;    case EVALUATING -> 0.5;    case INTERESTED -> 0.5;    case CLOSED -> 1;
    
    }
    
    ### 플루언트 API 설계와 Builder 패턴
    
    플루언트 API는 특정 문제를 직관적으로 해결할 수 있도록 특정 도메인에 맞춰진 API이다.
    
    빌더 패턴과 메소드 체이닝을 통해 복잡한 연산을 간단하게 처리할 수 있다.
    
    빌더패턴을 이용할 경우 해당 API의 사용자를 당혹스럽게하는
    
    - 빈 빌더의 인스턴스 화
    - Build() 메소드를 호출해야함 함
    
    과 같은 문제가 있다.
    
    이를 해결하기 위해 생성자를 private로 돌리고 가장 처음 앞에 와야하는 메소드에서 새로운 builder를 return 하도록, 가장 마지막의 메소드에 목표로 하는 객체를 return 하도록 코드를 구성할 수 있다.
